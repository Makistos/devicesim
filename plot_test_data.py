#!/usr/bin/env python3
"""
Data Visualization Script

Reads binary files generated by generate_test_data.py and visualizes the function outputs
using matplotlib. Can parse the definition file to understand the data structure and
create separate plots for each function.

Usage: python plot_test_data.py <definition_file> <binary_file> <count> [--bits {8,16,32}]
"""

import argparse
import struct
import sys
from typing import List, Tuple, Dict, Any
import matplotlib.pyplot as plt
import numpy as np
import re


class DataVisualizer:
    def __init__(self, bits: int = 8):
        """Initialize data visualizer with specified bit width."""
        self.bits = bits
        self.byte_format = {8: 'B', 16: 'H', 32: 'I'}[bits]
        self.signed_format = {8: 'b', 16: 'h', 32: 'i'}[bits]
        self.bytes_per_value = bits // 8

        # Store field information
        self.fields = []
        self.field_names = []

    def parse_definition_file(self, filepath: str) -> List[str]:
        """Parse definition file and return list of field definitions."""
        fields = []
        field_names = []

        try:
            with open(filepath, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()

                    # Skip empty lines and comments
                    if not line or line.startswith('#'):
                        continue

                    fields.append(line)

                    # Generate descriptive names for each field
                    if line.startswith('0x') or line.startswith('0X'):
                        field_names.append(f"Hex_{line}")
                    elif line.startswith('<') and line.endswith('>'):
                        # Extract function name
                        func_call = line.strip('<>')
                        func_name = func_call.split()[0] if func_call.split() else 'unknown'
                        field_names.append(f"Func_{func_name}")
                    elif line.lstrip('-').isdigit():
                        field_names.append(f"Decimal_{line}")
                    else:
                        field_names.append(f"Unknown_{line_num}")

            self.fields = fields
            self.field_names = field_names
            return fields

        except FileNotFoundError:
            print(f"Error: Definition file '{filepath}' not found.")
            sys.exit(1)
        except Exception as e:
            print(f"Error reading definition file: {e}")
            sys.exit(1)

    def read_binary_data(self, filepath: str, count: int, num_fields: int) -> np.ndarray:
        """Read binary data from file and return as numpy array."""
        try:
            with open(filepath, 'rb') as f:
                data = f.read()

            expected_size = count * num_fields * self.bytes_per_value
            if len(data) != expected_size:
                print(f"Warning: File size mismatch. Expected {expected_size} bytes, got {len(data)} bytes.")
                # Adjust count based on actual file size
                count = len(data) // (num_fields * self.bytes_per_value)
                print(f"Adjusting count to {count} samples.")

            # Unpack data
            format_char = '<' + self.byte_format  # Little-endian unsigned
            signed_format_char = '<' + self.signed_format  # Little-endian signed

            # Create array to hold all data
            data_array = np.zeros((count, num_fields), dtype=np.int32)

            offset = 0
            for sample in range(count):
                for field in range(num_fields):
                    # Read bytes for this value
                    value_bytes = data[offset:offset + self.bytes_per_value]
                    offset += self.bytes_per_value

                    # Unpack as unsigned first
                    unsigned_value = struct.unpack(format_char, value_bytes)[0]

                    # Convert to signed if necessary (for negative values)
                    max_unsigned = (2 ** self.bits) - 1
                    max_signed = (2 ** (self.bits - 1)) - 1

                    if unsigned_value > max_signed:
                        # This is a negative value in two's complement
                        signed_value = unsigned_value - (max_unsigned + 1)
                        data_array[sample, field] = signed_value
                    else:
                        data_array[sample, field] = unsigned_value

            return data_array

        except FileNotFoundError:
            print(f"Error: Binary file '{filepath}' not found.")
            sys.exit(1)
        except Exception as e:
            print(f"Error reading binary file: {e}")
            sys.exit(1)

    def identify_function_fields(self, fields: List[str]) -> Dict[str, List[int]]:
        """Identify which fields contain function outputs and group them by type."""
        function_fields = {}

        for i, field in enumerate(fields):
            if field.startswith('<') and field.endswith('>'):
                # Extract function name
                func_call = field.strip('<>')
                parts = func_call.split()
                if parts:
                    func_name = parts[0].lower()

                    if func_name not in function_fields:
                        function_fields[func_name] = []
                    function_fields[func_name].append(i)

        return function_fields

    def plot_all_fields(self, data: np.ndarray, save_path: str = None):
        """Create a comprehensive plot showing all fields."""
        num_samples, num_fields = data.shape

        # Calculate grid dimensions
        cols = min(3, num_fields)
        rows = (num_fields + cols - 1) // cols

        fig, axes = plt.subplots(rows, cols, figsize=(15, 4 * rows))
        if rows == 1:
            axes = [axes] if cols == 1 else axes
        else:
            axes = axes.flatten()

        # Plot each field
        for i in range(num_fields):
            ax = axes[i] if num_fields > 1 else axes

            field_data = data[:, i]
            field_name = self.field_names[i] if i < len(self.field_names) else f"Field_{i}"

            ax.plot(field_data, linewidth=1.5)
            ax.set_title(f"{field_name}\n{self.fields[i]}")
            ax.set_xlabel("Sample")
            ax.set_ylabel("Value")
            ax.grid(True, alpha=0.3)

            # Add statistics
            mean_val = np.mean(field_data)
            std_val = np.std(field_data)
            min_val = np.min(field_data)
            max_val = np.max(field_data)

            stats_text = f"μ={mean_val:.1f}, σ={std_val:.1f}\nmin={min_val}, max={max_val}"
            ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,
                   verticalalignment='top', fontsize=8,
                   bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

        # Hide unused subplots
        for i in range(num_fields, len(axes)):
            axes[i].set_visible(False)

        plt.tight_layout()

        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"Saved comprehensive plot to {save_path}")

        plt.show()

    def plot_functions_separately(self, data: np.ndarray, save_dir: str = None):
        """Create separate plots for each function type."""
        function_fields = self.identify_function_fields(self.fields)

        if not function_fields:
            print("No function fields found to plot separately.")
            return

        for func_name, field_indices in function_fields.items():
            fig, ax = plt.subplots(figsize=(12, 6))

            # Plot all instances of this function
            for i, field_idx in enumerate(field_indices):
                field_data = data[:, field_idx]
                label = f"{func_name}_{i}" if len(field_indices) > 1 else func_name
                ax.plot(field_data, label=label, linewidth=1.5)

            ax.set_title(f"Function: {func_name}")
            ax.set_xlabel("Sample")
            ax.set_ylabel("Value")
            ax.grid(True, alpha=0.3)

            if len(field_indices) > 1:
                ax.legend()

            # Add function definition as subtitle
            if field_indices:
                field_def = self.fields[field_indices[0]]
                ax.text(0.5, 0.95, field_def, transform=ax.transAxes,
                       horizontalalignment='center', fontsize=10,
                       bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.7))

            plt.tight_layout()

            if save_dir:
                save_path = f"{save_dir}/{func_name}_plot.png"
                plt.savefig(save_path, dpi=150, bbox_inches='tight')
                print(f"Saved {func_name} plot to {save_path}")

            plt.show()

    def plot_waveform_comparison(self, data: np.ndarray, save_path: str = None):
        """Create a comparison plot of different waveform functions."""
        function_fields = self.identify_function_fields(self.fields)

        waveform_functions = ['sine', 'square', 'triangle', 'sawtooth', 'qrs']
        available_waveforms = {name: indices for name, indices in function_fields.items()
                              if name in waveform_functions}

        if not available_waveforms:
            print("No waveform functions found for comparison.")
            return

        fig, ax = plt.subplots(figsize=(15, 8))

        colors = plt.cm.tab10(np.linspace(0, 1, len(available_waveforms)))

        for (func_name, field_indices), color in zip(available_waveforms.items(), colors):
            # Use the first instance of each function type
            field_data = data[:, field_indices[0]]
            ax.plot(field_data, label=func_name.capitalize(), color=color, linewidth=2)

        ax.set_title("Waveform Function Comparison")
        ax.set_xlabel("Sample")
        ax.set_ylabel("Value")
        ax.grid(True, alpha=0.3)
        ax.legend()

        plt.tight_layout()

        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"Saved waveform comparison to {save_path}")

        plt.show()

    def generate_statistics_report(self, data: np.ndarray) -> str:
        """Generate a text report with statistics for each field."""
        report = []
        report.append("Data Analysis Report")
        report.append("=" * 50)
        report.append(f"Data shape: {data.shape[0]} samples × {data.shape[1]} fields")
        report.append(f"Bit width: {self.bits} bits")
        report.append("")

        for i in range(data.shape[1]):
            field_data = data[:, i]
            field_name = self.field_names[i] if i < len(self.field_names) else f"Field_{i}"
            field_def = self.fields[i] if i < len(self.fields) else "Unknown"

            report.append(f"Field {i}: {field_name}")
            report.append(f"Definition: {field_def}")
            report.append(f"  Mean: {np.mean(field_data):.2f}")
            report.append(f"  Std:  {np.std(field_data):.2f}")
            report.append(f"  Min:  {np.min(field_data)}")
            report.append(f"  Max:  {np.max(field_data)}")
            report.append(f"  Range: {np.max(field_data) - np.min(field_data)}")

            # Check if it's a constant value
            if np.std(field_data) < 0.01:
                report.append("  Type: Constant value")
            elif field_def.startswith('<'):
                report.append("  Type: Function output")
            else:
                report.append("  Type: Static value")

            report.append("")

        return "\n".join(report)

    def visualize_data(self, definition_file: str, binary_file: str, count: int,
                      save_plots: bool = False):
        """Main function to visualize the data."""
        print(f"Analyzing data from {binary_file}...")

        # Parse definition file
        fields = self.parse_definition_file(definition_file)
        num_fields = len(fields)

        if num_fields == 0:
            print("No fields found in definition file.")
            return

        print(f"Found {num_fields} fields in definition file")

        # Read binary data
        data = self.read_binary_data(binary_file, count, num_fields)
        print(f"Read {data.shape[0]} samples with {data.shape[1]} fields each")

        # Generate statistics report
        stats_report = self.generate_statistics_report(data)
        print("\n" + stats_report)

        # Create visualizations
        print("\nGenerating plots...")

        # 1. Comprehensive plot of all fields
        save_path = "all_fields_plot.png" if save_plots else None
        self.plot_all_fields(data, save_path)

        # 2. Separate plots for each function
        save_dir = "function_plots" if save_plots else None
        if save_plots:
            import os
            os.makedirs(save_dir, exist_ok=True)
        self.plot_functions_separately(data, save_dir)

        # 3. Waveform comparison
        save_path = "waveform_comparison.png" if save_plots else None
        self.plot_waveform_comparison(data, save_path)

        # Save statistics report
        if save_plots:
            with open("data_analysis_report.txt", "w") as f:
                f.write(stats_report)
            print("Saved analysis report to data_analysis_report.txt")


def main():
    parser = argparse.ArgumentParser(
        description="Visualize binary test data generated by generate_test_data.py",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python plot_test_data.py graph_def.txt output.bin 1000
  python plot_test_data.py graph_def.txt output.bin 1000 --bits 16 --save

This script reads binary files generated by generate_test_data.py and creates
various visualizations of the function outputs.
        """
    )

    parser.add_argument('definition_file', help='Input definition file')
    parser.add_argument('binary_file', help='Binary data file to visualize')
    parser.add_argument('count', type=int, help='Number of data points in the file')
    parser.add_argument('--bits', choices=['8', '16', '32'], default='8',
                        help='Bit width for values (default: 8)')
    parser.add_argument('--save', action='store_true',
                        help='Save plots and analysis report to files')

    args = parser.parse_args()

    if args.count <= 0:
        print("Error: Count must be positive")
        sys.exit(1)

    visualizer = DataVisualizer(bits=int(args.bits))
    visualizer.visualize_data(args.definition_file, args.binary_file,
                            args.count, save_plots=args.save)


if __name__ == "__main__":
    main()
