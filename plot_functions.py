#!/usr/bin/env python3
"""
Enhanced Function Plotting Script

Reads binary files generated by generate_test_data.py and creates comprehensive
plots of the function outputs. This script focuses on the function outputs
and saves plots to files for easy viewing.

Usage: python plot_functions.py <definition_file> <binary_file> <count> [--bits {8,16,32}] [--output-dir OUTPUT_DIR]
"""

import argparse
import struct
import sys
import os
from typing import List, Tuple, Dict, Any
import matplotlib.pyplot as plt
import numpy as np
import re


class FunctionPlotter:
    def __init__(self, bits: int = 8):
        """Initialize function plotter with specified bit width."""
        self.bits = bits
        self.byte_format = {8: 'B', 16: 'H', 32: 'I'}[bits]
        self.signed_format = {8: 'b', 16: 'h', 32: 'i'}[bits]
        self.bytes_per_value = bits // 8

        # Store field information
        self.fields = []
        self.field_names = []

        # Set up matplotlib for non-interactive mode
        plt.switch_backend('Agg')

    def parse_definition_file(self, filepath: str) -> List[str]:
        """Parse definition file and return list of field definitions."""
        fields = []
        field_names = []

        try:
            with open(filepath, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()

                    # Skip empty lines and comments
                    if not line or line.startswith('#'):
                        continue

                    fields.append(line)

                    # Generate descriptive names for each field
                    if line.startswith('0x') or line.startswith('0X'):
                        field_names.append(f"Hex_{line}")
                    elif line.startswith('<') and line.endswith('>'):
                        # Extract function name
                        func_call = line.strip('<>')
                        func_name = func_call.split()[0] if func_call.split() else 'unknown'
                        field_names.append(f"Func_{func_name}")
                    elif line.lstrip('-').isdigit():
                        field_names.append(f"Decimal_{line}")
                    else:
                        field_names.append(f"Unknown_{line_num}")

            self.fields = fields
            self.field_names = field_names
            return fields

        except FileNotFoundError:
            print(f"Error: Definition file '{filepath}' not found.")
            sys.exit(1)
        except Exception as e:
            print(f"Error reading definition file: {e}")
            sys.exit(1)

    def read_binary_data(self, filepath: str, count: int, num_fields: int) -> np.ndarray:
        """Read binary data from file and return as numpy array."""
        try:
            with open(filepath, 'rb') as f:
                data = f.read()

            expected_size = count * num_fields * self.bytes_per_value
            if len(data) != expected_size:
                print(f"Warning: File size mismatch. Expected {expected_size} bytes, got {len(data)} bytes.")
                # Adjust count based on actual file size
                count = len(data) // (num_fields * self.bytes_per_value)
                print(f"Adjusting count to {count} samples.")

            # Unpack data
            format_char = '<' + self.byte_format  # Little-endian unsigned

            # Create array to hold all data
            data_array = np.zeros((count, num_fields), dtype=np.int32)

            offset = 0
            for sample in range(count):
                for field in range(num_fields):
                    # Read bytes for this value
                    value_bytes = data[offset:offset + self.bytes_per_value]
                    offset += self.bytes_per_value

                    # Unpack as unsigned first
                    unsigned_value = struct.unpack(format_char, value_bytes)[0]

                    # Convert to signed if necessary (for negative values)
                    max_unsigned = (2 ** self.bits) - 1
                    max_signed = (2 ** (self.bits - 1)) - 1

                    if unsigned_value > max_signed:
                        # This is a negative value in two's complement
                        signed_value = unsigned_value - (max_unsigned + 1)
                        data_array[sample, field] = signed_value
                    else:
                        data_array[sample, field] = unsigned_value

            return data_array

        except FileNotFoundError:
            print(f"Error: Binary file '{filepath}' not found.")
            sys.exit(1)
        except Exception as e:
            print(f"Error reading binary file: {e}")
            sys.exit(1)

    def identify_function_fields(self, fields: List[str]) -> Dict[str, List[int]]:
        """Identify which fields contain function outputs and group them by type."""
        function_fields = {}

        for i, field in enumerate(fields):
            if field.startswith('<') and field.endswith('>'):
                # Extract function name
                func_call = field.strip('<>')
                parts = func_call.split()
                if parts:
                    func_name = parts[0].lower()

                    if func_name not in function_fields:
                        function_fields[func_name] = []
                    function_fields[func_name].append(i)

        return function_fields

    def plot_all_functions(self, data: np.ndarray, output_dir: str = "plots"):
        """Create comprehensive plots of all function outputs."""
        os.makedirs(output_dir, exist_ok=True)

        # Identify function fields
        function_fields = self.identify_function_fields(self.fields)

        if not function_fields:
            print("No function fields found in definition file.")
            return

        # Create individual plots for each function type
        for func_name, field_indices in function_fields.items():
            print(f"Plotting {func_name} function...")

            fig, axes = plt.subplots(len(field_indices), 1, figsize=(12, 4 * len(field_indices)))
            if len(field_indices) == 1:
                axes = [axes]

            for i, field_idx in enumerate(field_indices):
                ax = axes[i] if len(field_indices) > 1 else axes[0]

                field_data = data[:, field_idx]
                field_name = self.field_names[field_idx]
                field_def = self.fields[field_idx]

                # Plot the data
                ax.plot(field_data, linewidth=2, color=self.get_function_color(func_name))
                ax.set_title(f"{field_name}\nDefinition: {field_def}")
                ax.set_xlabel("Sample Index")
                ax.set_ylabel("Value")
                ax.grid(True, alpha=0.3)

                # Add statistics
                mean_val = np.mean(field_data)
                std_val = np.std(field_data)
                min_val = np.min(field_data)
                max_val = np.max(field_data)

                stats_text = f"μ={mean_val:.2f}, σ={std_val:.2f}\nmin={min_val}, max={max_val}"
                ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,
                       verticalalignment='top', fontsize=10,
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

                # Add specific annotations for different function types
                self.add_function_annotations(ax, func_name, field_data, field_def)

            plt.tight_layout()

            # Save the plot
            filename = f"{func_name}_function.png"
            filepath = os.path.join(output_dir, filename)
            plt.savefig(filepath, dpi=150, bbox_inches='tight')
            print(f"  Saved {filename}")
            plt.close()

        # Create a combined overview plot
        self.plot_functions_overview(data, function_fields, output_dir)

    def plot_functions_overview(self, data: np.ndarray, function_fields: Dict[str, List[int]], output_dir: str):
        """Create an overview plot showing all functions together."""
        print("Creating functions overview plot...")

        # Calculate grid dimensions
        total_functions = len(function_fields)
        cols = min(3, total_functions)
        rows = (total_functions + cols - 1) // cols

        fig, axes = plt.subplots(rows, cols, figsize=(15, 5 * rows))
        if rows == 1:
            axes = [axes] if cols == 1 else axes
        else:
            axes = axes.flatten()

        plot_idx = 0
        for func_name, field_indices in function_fields.items():
            if plot_idx >= len(axes):
                break

            ax = axes[plot_idx]

            # Plot all instances of this function
            for field_idx in field_indices:
                field_data = data[:, field_idx]
                field_name = self.field_names[field_idx]

                ax.plot(field_data, linewidth=2, label=field_name,
                       color=self.get_function_color(func_name))

            ax.set_title(f"{func_name.title()} Function")
            ax.set_xlabel("Sample Index")
            ax.set_ylabel("Value")
            ax.grid(True, alpha=0.3)
            ax.legend()

            plot_idx += 1

        # Hide unused subplots
        for i in range(plot_idx, len(axes)):
            axes[i].set_visible(False)

        plt.tight_layout()

        # Save the overview plot
        filepath = os.path.join(output_dir, "functions_overview.png")
        plt.savefig(filepath, dpi=150, bbox_inches='tight')
        print(f"  Saved functions_overview.png")
        plt.close()

    def get_function_color(self, func_name: str) -> str:
        """Get a color for a specific function type."""
        colors = {
            'sine': '#1f77b4',      # Blue
            'square': '#ff7f0e',    # Orange
            'triangle': '#2ca02c',  # Green
            'sawtooth': '#d62728',  # Red
            'random': '#9467bd',    # Purple
            'qrs': '#8c564b',       # Brown
            'linear': '#e377c2',    # Pink
            'exponential': '#7f7f7f', # Gray
            'logarithmic': '#bcbd22', # Olive
            'gaussian': '#17becf'   # Cyan
        }
        return colors.get(func_name.lower(), '#000000')

    def add_function_annotations(self, ax, func_name: str, data: np.ndarray, field_def: str):
        """Add specific annotations for different function types."""
        if func_name.lower() == 'sine':
            # Mark peaks and valleys
            peaks = []
            valleys = []
            for i in range(1, len(data) - 1):
                if data[i] > data[i-1] and data[i] > data[i+1]:
                    peaks.append(i)
                elif data[i] < data[i-1] and data[i] < data[i+1]:
                    valleys.append(i)

            if peaks:
                ax.scatter(peaks, data[peaks], color='red', s=30, alpha=0.7, label='Peaks')
            if valleys:
                ax.scatter(valleys, data[valleys], color='blue', s=30, alpha=0.7, label='Valleys')

        elif func_name.lower() == 'square':
            # Mark transitions
            transitions = []
            for i in range(1, len(data)):
                if data[i] != data[i-1]:
                    transitions.append(i)

            if transitions:
                ax.axvline(x=transitions[0], color='red', linestyle='--', alpha=0.7, label='Transitions')
                for t in transitions[1:]:
                    ax.axvline(x=t, color='red', linestyle='--', alpha=0.7)

        elif func_name.lower() == 'qrs':
            # Mark R-wave peaks
            r_peaks = []
            for i in range(len(data)):
                if i > 0 and data[i] > data[i-1] and data[i] > 0:
                    r_peaks.append(i)

            if r_peaks:
                ax.scatter(r_peaks, data[r_peaks], color='red', s=50, alpha=0.8,
                          marker='^', label='R-peaks')


def main():
    parser = argparse.ArgumentParser(description='Plot function outputs from binary test data')
    parser.add_argument('definition_file', help='Definition file (.txt)')
    parser.add_argument('binary_file', help='Binary data file (.bin)')
    parser.add_argument('count', type=int, help='Number of samples to read')
    parser.add_argument('--bits', type=int, choices=[8, 16, 32], default=8,
                       help='Bit width of data values (default: 8)')
    parser.add_argument('--output-dir', default='plots',
                       help='Output directory for plots (default: plots)')

    args = parser.parse_args()

    # Create plotter instance
    plotter = FunctionPlotter(args.bits)

    # Parse definition file
    print(f"Reading definition file: {args.definition_file}")
    fields = plotter.parse_definition_file(args.definition_file)
    print(f"Found {len(fields)} fields in definition file")

    # Read binary data
    print(f"Reading binary data from: {args.binary_file}")
    data = plotter.read_binary_data(args.binary_file, args.count, len(fields))
    print(f"Read {data.shape[0]} samples with {data.shape[1]} fields each")

    # Generate plots
    print(f"Generating plots in directory: {args.output_dir}")
    plotter.plot_all_functions(data, args.output_dir)

    print("Plotting complete!")
    print(f"Check the '{args.output_dir}' directory for generated plots.")


if __name__ == '__main__':
    main()
